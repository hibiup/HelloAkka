############################################
# Akka Cluster 配置：
#
# Akka Cluster 以 p2p 方式形成集群，节点(node)之间地位基本是平等的，除了集群初始化（seed-nodes 中的第一个 actor 启动的时候）之外，
# 它们会自动选举出 leader。
#
# Node 是一个 actor system 进程，即便没有 actor 存在，只要启动 actor system 就会自动注册为一个节点。节点也可以通过代码而不是配置
# 文件来注册，参考：https://doc.akka.io/docs/akka/current/cluster-usage.html
#
#   val cluster = Cluster(context.system)
#   cluster.join(cluster.selfAddress)
#
# 之所以初始化必须由第一个 node 来完成是为了避免出现节点"孤岛"（多个集群）现象。集群初始化的时候 seed-nodes 中的第一个节点必须首
# 先被启动，否则后续节点将无法加入，一旦第一个节点被启动后续节点的启动顺序可以随意，在有新的节点被加入后，第一个节点再被关闭也不会对
# 集群产生影响。因此一般来说集群中至少需要两个节点互为备份。
#
# 新的 node 启动的时候，它尝试向 seed-nodes 中的每一个其他节点发送出 join 消息并接受第一个回复的邀请，如果没有任何节
# 点回复，那么会不断尝试直到被关闭为止。
#
akka.cluster {
    # 节点的名称`ClusterSystem`必须和 ActorSystem(参见 ServerMain 中) 的名称一致
    seed-nodes = [
        "akka://ClusterSystem@localhost:2551",
        "akka://ClusterSystem@localhost:2552"
    ]
}

############################################
# 配置本节点的侦听端口
#
# 当 node 启动的时候，它首先打开自己的侦听端口：
# ... Remoting started with transport [Artery tcp]; listening on address [akka://ClusterSystem@localhost:2551] with UID [3564469129744278562]
#
# 然后根据上面 cluster.seed-nodes 中的配置尝试和所有节点通讯，如果它发现自己是该集群中的第一个节点，并且其他节点没有回复消息：
# ... [outbound connection to [akka://ClusterSystem@localhost:2552], message stream] Upstream failed, cause: StreamTcpException: Tcp command [Connect(localhost:2552,None,List(),Some(5000 milliseconds),true)] failed because of java.net.ConnectException: Connection refused
# ... [outbound connection to [akka://ClusterSystem@localhost:2552], control stream] Upstream failed, cause: StreamTcpException: Tcp command [Connect(localhost:2552,None,List(),Some(5000 milliseconds),true)] failed because of java.net.ConnectException: Connection refused
#
# 那么它将会加入自己（join self）然后作为缺省角色(dc-default)建立新的集群，并将自己选为 leader：
# ... Cluster Node [akka://ClusterSystem@localhost:2551] - Node [akka://ClusterSystem@localhost:2551] is JOINING itself (with roles [dc-default]) and forming new cluster
# ... Cluster Node [akka://ClusterSystem@localhost:2551] - is the new leader among reachable nodes (more leaders may exist)
# ... Cluster Node [akka://ClusterSystem@localhost:2551] - Leader is moving node [akka://ClusterSystem@localhost:2551] to [Up]
# ... Member is Up: akka://ClusterSystem@localhost:2551
#
# 如果我们把端口修改为列表中第二个以后节点的端口，那么可以观察到它只会不断去尝试 join，而不会启动集群。
#
akka.remote {
    artery.canonical {    # 服务引擎，可以换成 netty
        # 缺省监听端口，实际上以下选项无需配置，因为不同的节点需要不同的（ip 和 port）配置，因此一般以命令行形式传入。
        hostname = "localhost"
        port = 2551
    }
}

#
akka.actor {
    # 需要明确告知每个 actor 其运行环境为 cluster
    provider = "cluster"

    default-dispatcher {
        # Throughput for default Dispatcher, set to 1 for as fair as possible
        throughput = 10
    }

    # For Akka cluster data serialization
    serializers {
        jackson-json = "akka.serialization.jackson.JacksonJsonSerializer"
        jackson-cbor = "akka.serialization.jackson.JacksonCborSerializer"
        proto = "akka.remote.serialization.ProtobufSerializer"
    }
}

akka {
    log-dead-letters-during-shutdown = on
    loglevel = "INFO"
    log-dead-letters = on
    log-config-on-start = off    # Log the complete configuration at INFO level when the actor system is started

    loggers = ["akka.event.slf4j.Slf4jLogger"]
    logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"
}

akka {
    extensions=[
        "akka.cluster.metrics.ClusterMetricsExtension"
    ]
}
